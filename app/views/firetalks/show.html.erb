<script type="text/javascript" src="https://static.opentok.com/v2/js/opentok.min.js"></script>

<%= 'FIRETALK SHOW VIEW' %>

<div id="clock">10</div>
<div id="pointsLeft">3</div>
<p>ROUND NUMBER</p>
<div id="roundNumber">1</div>

<div id="speaker1Box" style="border: 1px solid;"></div>
<div id="speaker2Box"></div>
<div id="speaker3Box"></div>
<div id="speaker4Box"></div>
<div id="speaker5Box"></div>
<div id="speaker6Box"></div>

<div id="speakerOnePoints">0</div>
<div id="speakerTwoPoints">0</div>
<div id="speakerThreePoints">0</div>
<div id="speakerThreePoints">0</div>
<div id="speakerFourPoints">0</div>
<div id="speakerFivePoints">0</div>
<div id="speakerSixPoints">0</div>

<%= javascript_tag do %>
var apiKey = '45241592';
var sessionId = "<%= j @firetalk.tok_session_id %>";
var token = "<%= j @tok_token %>";
var myEmail = "<%= j @user.email %>"
var debatersJson = JSON.parse("<%= j @firetalk_json.to_s.html_safe %>");

// starting number of points
var votingPoints = 3;

// connecting logic
TB.setLogLevel(TB.DEBUG);
var session = TB.initSession(sessionId);
var totalSessions = [];
var audioSubscribers = [];

session.addEventListener('sessionConnected', sessionConnectedHandler);
session.addEventListener('streamCreated', streamCreatedHandler);
session.connect(apiKey, token);

var publisher;
var speakerNumber;

function sessionConnectedHandler(event) {
    speakerNumber = parseInt(debatersJson[myEmail] + 1);
    publisher = OT.initPublisher(apiKey, "speaker" + speakerNumber + "Box");
    session.publish(publisher);

    // Subscribe to streams that were in the session when we connected
    subscribeToStreams(event.streams);
}

function streamCreatedHandler(event) {
    subscribeToStreams(event.streams);
}

function subscribeToStreams(streams) {
  for (var i = 0; i < streams.length; i++) {
    // Make sure we donâ€™t subscribe to ourself
    if (streams[i].connection.connectionId != session.connection.connectionId) {
      // Create the div to put the subscriber element in to
      var div = document.createElement('div');
      div.setAttribute('id', 'stream' + streams[i].streamId);

      var connection = streams[i].connection;
      var email = connection.data.split("|")[1];
      var newSpeakerNumber = parseInt(debatersJson[email]) + 1;
      document.getElementById("speaker" + newSpeakerNumber + "Box").appendChild(div);

      // Subscribe to the stream
      var subscriber = session.subscribe(streams[i], div.id);
      audioSubscribers.push(subscriber);
    }
  }
}

// BROADCAST SIGNAL EVENTS
$('#speakerOnePoints').click(function() {
  session.signal(
    {
      data: totalSessions[0].connection.connectionId,
      type: "voteSpeakerOne"
    },
    function(error) {
      if (error) {
        alert(error.message);
      }
    }
  );
});

$('#speakerTwoPoints').click(function() {
  session.signal(
    {
      data:  totalSessions[1].connection.connectionId,
      type: "voteSpeakerTwo"
    },
    function(error) {
      if (error) {
        alert(error.message);
      }
    }
  );
});

// LISTENER EVENTS

// Listener SpeakerOneUpvote
session.on(
  "signal:voteSpeakerOne", function(event) {
    var newPoints = incrementStream(event.data);
    $('#speakerOnePoints').html(newPoints);
  }
);

// Listener SpeakerTwoUpvote
session.on(
  "signal:voteSpeakerTwo", function(event) {
    var newPoints = incrementStream(event.data);
    $('#speakerTwoPoints').html(newPoints);
  }
);

// Stores the points of the connection locally and returns the value
function incrementStream(connectionId) {
  for (var i = 0; i < totalSessions.length; i++) {
    if (String(totalSessions[i].connection.connectionId) == String(connectionId)) {
      var data = totalSessions[i].connection.data.split("|");
      totalSessions[i].connection.data = parseInt(data[0]) + 1 + "|" + data[1];
      return parseInt(data[0]) + 1;
    }
  }
  return 0;
}

// Get whoever connected and add to list
session.on(
  "connectionCreated", function(event) {
    var emailAndPoints = event.connection.data.split("|");

    // JSON points email => Speaker number
    // totalSessions puts people in the right order by speaker number
    totalSessions[parseInt(debatersJson[emailAndPoints[1]])] = event;
  }
);

// Listen to ourselves if we lose
session.on(
  "signal:disconnect", function(event) {
    alert("disconnecting " + event.data);
    if (session.connection.connectionId == event.data) {
      session.unpublish(publisher);
    }
    else {
      for (var i = 0; i < audioSubscribers.length; i++) {
        // either kill video or just kill audio
        if (audioSubscribers[i].stream.connection.connectionId == event.data) {
          audioSubscribers[i].setAudioVolume(0);
        }
      }
      for (var i = 0; i < totalSessions.length; i++) {
        if (totalSessions[i].connection.connectionId == event.data) {
          var number = i + 1;
          $('#speaker' + number + 'Box').hide();
        }
      }
    }
  });

session.on(
  "signal:decrementClock", function(event) {
    var currentTime = $('#clock');
    currentTime.html(event.data);
});

session.on(
  "signal:resetTimer", function(event) {
  $('#clock').html("10");
});

session.on(
  "signal:nextSpeaker", function(event) {
    for (var i = 0; i < audioSubscribers.length; i++) {
      if (audioSubscribers[i].stream.connection.connectionId == event.data) {
        audioSubscribers[i].setAudioVolume(100);
      }
      else {
        audioSubscribers[i].setAudioVolume(0);
      }
      if (event.data == session.connection.connectionId) {
        document.getElementById('speaker' + speakerNumber + 'Box').style.backgroundColor = "red";
        alert("you are speaking now!");
      }
    }
  }
);

session.on(
  "signal:nextRound", function(event) {
    var currentRound = $('#roundNumber');
    currentRound.html(event.data);
  }
)
<% end %>

<% if session[:user_id].to_s == params[:user_id].to_s %>
  <%= javascript_tag do %>
  function startFiretalk() {
    $('#startFiretalk').hide();

    // OWNER LOGIC (Clock every second, muting people, etc.)
    // WRAP IN START FUNCTION, EXECUTE ON CLICK

    // Players alive is an array containing the connectionIds of all debaters
    // throughout the firetalk we will nullify the connections that are dropped
    // each round, and keep track of the next speaker (connectionId) in line
    var playersAlive = [];
    for (var i = 0; i < totalSessions.length; i++) {
      playersAlive[i] = totalSessions[i].connection.connectionId;
    }

    // OWNER START SPEAKING
    session.signal({
      type: "nextSpeaker",
      data: session.connection.connectionId
    },
    function(error) {
      if (error) {
        alert("There was an error starting the firetalk with owner");
      }
    });

    var timer = null;
    if (!timer) {
      timer = setInterval(clockwork, 1000);
    }

    var totalRounds = 3;
    var currentRound = 1;
    var currentSpeakerIndex = 0;

    // Firetalk logic function
    // First speaker (owner) is ALREADY speaking when this method is called
    function clockwork() {
      // Clock logic
      var currentTimeLeft = parseInt($('#clock').text(), 10);

      // Timer Still going
      if (currentTimeLeft > 0) {
        var newTime = currentTimeLeft - 1;

        // Lets stick these in helper methods
        session.signal({
          data: newTime,
          type: "decrementClock"
        },
        function(error) {
          if (error) {
            alert("Failed to update clock, who the fuck knows");
          }
        });
      }
      // Timer Ended (30 seconds up!)
      else {
        // unmute next person, mute everyone else and reset clock to 30 sec (another signal func)
        // if the round is over (bool var?) disconnect the lowest session
        // if we've got a winner, stop everything
        session.signal({
          type: "resetTimer"
        }, function(error) {
          if (error) {
            alert("Failed to reset clock");
          }
        });

        // If we have reached the last speaker (a.k.a it's time for a new round)
        if (isLastSpeakerAlive(currentSpeakerIndex)) {
          alert("reached the last speaker at the end of the timer, current round is" + currentRound);
          // Go back to the beginning of our list at the end of the round
          currentSpeakerIndex = 0;

          // otherwise increment the round and do it again!
          // and drop the lowest dude
          currentRound++;
          dropLowest();
          playersAlive[lowestPointsIndex()] = null;
          session.signal({
            type: "nextRound",
            data: currentRound
          },
          function(error) {
            if (error) {
              alert("Failed to tell everyone to increment round...");
            }
          });
          // If it's the end of the firetalk
          if (currentRound == totalRounds) {
            alert("END OF FIRETALK");
            // Do some winner logic
            clearInterval(timer);
            timer = null;
          }
        }
        // There are still more people left to speak (guaranteed)
        else {
          currentSpeakerIndex++;
          for (var i = currentSpeakerIndex; i < playersAlive.length; i++) {
            var connectionId = playersAlive[i];
            if (connectionId) {
              session.signal({
                type: "nextSpeaker",
                data: connectionId
              },
              function(error) {
                if (error) {
                  alert("There was an error unmuting the next speaker");
                }
              });
              break;
            }
          }
        }
      }
    }

    // Checks if the given index is the last speaker alive
    // or that the rest of the elements after it are null
    function isLastSpeakerAlive(index) {
      if (index == 5) {
        return true;
      }
      for (var i = index + 1; i < playersAlive.length; i++) {
        if (playersAlive[i]) {
          return false;
        }
      }
      return true;
    }

    function lowestPointsIndex() {
      var lowestIndex = 0;
      var lowestConnection = totalSessions[0].connection;
      for (var i = 0; i < totalSessions.length; i++) {
        var lowestConnectionPoints = parseInt(lowestConnection.data.split("|")[0]);
        var compareConnectionPoints = parseInt(totalSessions[i].connection.data.split("|")[0]);
        if (compareConnectionPoints < lowestConnectionPoints) {
          lowestConnection = totalSessions[i];
          lowestIndex = i;
        }
      }
      return lowestIndex;
    }

    function dropLowest() {
      alert("dropping lowest...");
      var lowestConnection = totalSessions[0].connection;
      for (var i = 1; i < totalSessions.length; i++) {
        var lowestConnectionPoints = parseInt(lowestConnection.data.split("|")[0]);
        var compareConnectionPoints = parseInt(totalSessions[i].connection.data.split("|")[0]);
        if (compareConnectionPoints < lowestConnectionPoints) {
          lowestConnection = totalSessions[i].connection;
        }
      }
      session.signal(
        {
          type: "disconnect",
          data: lowestConnection.connectionId
        },
        function(error) {
          console.log("signal error (" + error.code + "): " + error.message);
        }
      );
    }
  }
  <% end %>
<% end %>

<% if @user.id == @firetalk.user_id %>
  <button onclick="startFiretalk()" id="startFiretalk">Start Firetalk</button>
<% end %>
