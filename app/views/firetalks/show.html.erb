<script type="text/javascript" src="https://static.opentok.com/v2/js/opentok.min.js"></script>

<%= 'FIRETALK SHOW VIEW' %>

<div id="clock">10</div>
<div id="pointsLeft">3</div>
<p>ROUND NUMBER</p>
<div id="roundNumber">1</div>

<span>Speaker One</span>
<div id="speaker1Box" class="speakerBox"></div>
<span>Speaker Two</span>
<div id="speaker2Box" class="speakerBox"></div>
<span>Speaker Three</span>
<div id="speaker3Box" class="speakerBox"></div>
<div id="speaker4Box" class="speakerBox"></div>
<div id="speaker5Box" class="speakerBox"></div>
<div id="speaker6Box" class="speakerBox"></div>

<div id="speakerOnePoints" class="speakerPoints">0</div>
<div id="speakerTwoPoints" class="speakerPoints">0</div>
<div id="speakerThreePoints" class="speakerPoints">0</div>
<div id="speakerThreePoints" class="speakerPoints">0</div>
<div id="speakerFourPoints" class="speakerPoints">0</div>
<div id="speakerFivePoints" class="speakerPoints">0</div>
<div id="speakerSixPoints" class="speakerPoints">0</div>

<%= javascript_tag do %>
var apiKey = '45241592';
var sessionId = "<%= j @firetalk.tok_session_id %>";
var token = "<%= j @tok_token %>";
var myEmail = "<%= j @user.email %>"
var debatersJson = JSON.parse("<%= j @firetalk_json.to_s.html_safe %>");
var isDebater = "<%= @is_debater %>"

// connecting logic
TB.setLogLevel(TB.DEBUG);
var session = TB.initSession(sessionId);
var totalSessions = [];


var totalPoints = $('.speakerPoints');
for (var i = 0; i < totalPoints.length; i++) {
  totalPoints[i].style.visibility = "hidden";
}

session.addEventListener('sessionConnected', sessionConnectedHandler);
session.addEventListener('streamCreated', streamCreatedHandler);
session.addEventListener('streamPropertyChanged', streamPropertyChangedHandler)
session.connect(apiKey, token);

var publisher;
var speakerNumber;

function sessionConnectedHandler(event) {
  var myDiv = document.createElement('div');
  speakerNumber = parseInt(debatersJson[myEmail] + 1);
  publisher = OT.initPublisher(apiKey, myDiv);
  document.getElementById("speaker" + speakerNumber + "Box").appendChild(myDiv);
  if (isDebater) {
    session.publish(publisher);
  }
  var id = document.createTextNode(String(session.connection.connectionId));
  document.body.appendChild(id);

  // Subscribe to streams that were in the session when we connected
  subscribeToStreams(event.streams);
}

function streamCreatedHandler(event) {
    subscribeToStreams(event.streams);
}

function subscribeToStreams(streams) {
  for (var i = 0; i < streams.length; i++) {
    // Make sure we donâ€™t subscribe to ourself
    if (streams[i].connection.connectionId == session.connection.connectionId) {
      return;
    }
    // Create the div to put the subscriber element in to
    var div = document.createElement('div');
    div.setAttribute('id', 'stream' + streams[i].streamId);

    var connection = streams[i].connection;
    var email = connection.data.split("|")[1];
    var newSpeakerNumber = parseInt(debatersJson[email]) + 1;
    document.getElementById("speaker" + newSpeakerNumber + "Box").appendChild(div);

    // Subscribe to the stream
    session.subscribe(streams[i], div.id);
  }
}

function streamPropertyChangedHandler() {

}

function decrementVote() {
  var points = document.getElementById("pointsLeft");
  var left = points.innerHTML;
  points.innerHTML = parseInt(left) - 1;
}

function getPoints() {
  return parseInt(document.getElementById('pointsLeft').innerHTML);
}

// BROADCAST SIGNAL EVENTS
$('#speakerOnePoints').click(function() {
  if (hasPointsLeft()) {
    decrementVote();
    session.signal(
      {
        data: totalSessions[0].connection.connectionId,
        type: "voteSpeakerOne"
      },
      function(error) {
        if (error) {
          alert(error.message);
        }
      }
    );
  }
});

$('#speakerTwoPoints').click(function() {
  if (hasPointsLeft()) {
    session.signal(
      {
        data:  totalSessions[1].connection.connectionId,
        type: "voteSpeakerTwo"
      },
      function(error) {
        if (error) {
          alert(error.message);
        }
      }
    );
    decrementVote();
  }
});

function hasPointsLeft() {
  var points = parseInt(document.getElementById("pointsLeft").innerHTML);
  return points > 0;
}

// LISTENER EVENTS
session.on(
  "signal:winnerColor", function(event) {
    var email;
    for (var i = 0; i < totalSessions.length; i++) {
      if (totalSessions[i].connection.connectionId == event.data) {
        email = totalSessions[i].connection.data.split("|")[1];
      }
    }
    speakerIndex = parseInt(debatersJson[email]) + 1;
    document.getElementById('speaker' + speakerIndex + 'Box').style.backgroundColor = "yellow";
  }
);
session.on(
  "signal:decrementVote", function(event) {
    document.getElementById('pointsLeft').innerHTML = event.data;
  }
);

// Listener SpeakerOneUpvote
session.on(
  "signal:voteSpeakerOne", function(event) {
    var newPoints = incrementStream(event.data);
    $('#speakerOnePoints').html(newPoints);
  }
);

// Listener SpeakerTwoUpvote

session.on(
  "signal:voteSpeakerTwo", function(event) {
    var newPoints = incrementStream(event.data);
    $('#speakerTwoPoints').html(newPoints);
  }
);

// Stores the points of the connection locally and returns the value
function incrementStream(connectionId) {
  for (var i = 0; i < totalSessions.length; i++) {
    if (String(totalSessions[i].connection.connectionId) == String(connectionId)) {
      var data = totalSessions[i].connection.data.split("|");
      totalSessions[i].connection.data = parseInt(data[0]) + 1 + "|" + data[1];
      return parseInt(data[0]) + 1;
    }
  }
  return 0;
}

// Get whoever connected and add to list
session.on(
  "connectionCreated", function(event) {
    var emailAndPoints = event.connection.data.split("|");

    // JSON points email => Speaker number
    // totalSessions puts people in the right order by speaker number
    totalSessions[parseInt(debatersJson[emailAndPoints[1]])] = event;
  }
);

// Listen to ourselves if we lose
session.on(
  "signal:disconnect", function(event) {
    if (session.connection.connectionId == event.data) {
      // Instead of just unpublishing, permanently mute and set style to black
      alert("sending drop color signal");
      publisher.publishAudio(false);
      document.getElementById('speaker' + speakerNumber + 'Box').style.backgroundColor = "black";

      session.signal({
        type: 'dropColor',
        data: session.connection.connectionId
      }, function(error) {
        if (error) {
          console.log("problem changing colors");
        }
      }
    );
    }
  }
);

session.on(
  "signal:dropColor", function(event) {
    var email;
    for (var i = 0; i < totalSessions.length; i++) {
      if (totalSessions[i].connection.connectionId == event.data) {
        email = totalSessions[i].connection.data.split("|")[1];
      }
    }
    var debaterIndex = parseInt(debatersJson[email]);
    debaterIndex++;
    document.getElementById('speaker' + debaterIndex + 'Box').style.backgroundColor = "black";
  }
);

session.on(
  "signal:decrementClock", function(event) {
    var currentTime = $('#clock');
    currentTime.html(event.data);
});

session.on(
  "signal:resetTimer", function(event) {
  $('#clock').html("10");
});

session.on(
  "signal:adjustAudio", function(event) {
    var email;
    for (var i = 0; i < totalSessions.length; i++) {
      if (totalSessions[i].connection.connectionId == event.data) {
        email = totalSessions[i].connection.data.split("|")[1];
      }
    }
    var nowSpeaking = parseInt(debatersJson[email]);
    var totalSpeakerBoxes = $('.speakerBox');
    for (var i = 0; i < totalSpeakerBoxes.length; i++) {
      if (i == nowSpeaking) {
        totalSpeakerBoxes[i].style.backgroundColor = "green";
      }
      else if (totalSpeakerBoxes[i].style.backgroundColor != "black"){
        totalSpeakerBoxes[i].style.backgroundColor = "red";
      }
    }
    // Don't worry about this, it's just muting stuff
    if (event.data == session.connection.connectionId) {
      alert("your turn to speak");
      //$("#speaker" + speakerNumber + "Box").css("background-color", "green");
      publisher.publishAudio(true);
    }
    else {
      publisher.publishAudio(false);
    }
  }
);

session.on(
  "signal:nextRound", function(event) {
    var currentRound = $('#roundNumber');
    currentRound.html(event.data);
  }
);

session.on(
  "signal:removeButtons", function(event) {
    var myIndex = parseInt(debatersJson[myEmail]);
    $('button.OT_edge-bar-item.OT_mute.OT_mode-auto').each(function(index) {
      if (myIndex == index) {
        $(this).hide();
      }
    });
  }
);

session.on(
  "signal:unmuteAll", function(event) {
    publisher.publishAudio(true);
  }
);

session.on(
  "signal:showPoints", function(event) {
    var points = $('.speakerPoints');
    for (var i = 0; i < points.length; i++) {
      points[i].style.visibility = 'visible';
    }
  }
)

session.on(
  "signal:newPoints", function(event) {
    var newPoints = parseInt(event.data);
    document.getElementById("pointsLeft").innerHTML = newPoints;
  }
)
<% end %>

<% if session[:user_id].to_s == params[:user_id].to_s %>
  <%= javascript_tag do %>

  function showPoints() {
    session.signal({
      type: "showPoints"
    }, function(error) {
      if (error) {
        alert("couldn't show points");
      }
    });
  }

  function startFiretalk() {
    $('#startFiretalk').hide();
    showPoints();
    session.signal({
      type: "removeButtons"
      }, function(error) {
        if (error) {
          alert("couldn't tell people to fix buttons");
        }
    });

    // OWNER LOGIC (Clock every second, muting people, etc.)
    // WRAP IN START FUNCTION, EXECUTE ON CLICK

    // Players alive is an array containing the connectionIds of all debaters
    // throughout the firetalk we will nullify the connections that are dropped
    // each round, and keep track of the next speaker (connectionId) in line
    var playersAlive = [];
    for (var i = 0; i < totalSessions.length; i++) {
      if (totalSessions[i]) {
        playersAlive[i] = totalSessions[i].connection.connectionId;
      }
    }

    // OWNER START SPEAKING
    session.signal({
      type: "adjustAudio",
      data: session.connection.connectionId
    },
    function(error) {
      if (error) {
        alert("There was an error starting the firetalk with owner");
      }
    });

    var timer = null;
    if (!timer) {
      timer = setInterval(clockwork, 1000);
    }

    var totalRounds = 3;
    var currentRound = 1;
    var currentSpeakerIndex = 0;

    // Firetalk logic function
    // First speaker (owner) is ALREADY speaking when this method is called
    function clockwork() {
      // Clock logic
      var currentTimeLeft = parseInt($('#clock').text(), 10);

      // Timer Still going
      if (currentTimeLeft > 0) {
        var newTime = currentTimeLeft - 1;

        // Lets stick these in helper methods
        session.signal({
          data: newTime,
          type: "decrementClock"
        },
        function(error) {
          if (error) {
            alert("Failed to update clock, who knows");
          }
        });
      }
      // Timer Ended (30 seconds up!)
      else {
        // unmute next person, mute everyone else and reset clock to 30 sec (another signal func)
        // if the round is over (bool var?) disconnect the lowest session
        // if we've got a winner, stop everything
        session.signal({
          type: "resetTimer"
        }, function(error) {
          if (error) {
            alert("Failed to reset clock");
          }
        });

        // If we have reached the last speaker (a.k.a it's time for a new round)
        if (isLastSpeakerAlive(currentSpeakerIndex)) {
          alert("reached the last speaker at the end of the timer, current round is " + currentRound);
          // Go back to the beginning of our list at the end of the round
          currentSpeakerIndex = 0;

          // otherwise increment the round and do it again!
          // and drop the lowest dude
          currentRound++;
          dropLowest();
          session.signal({
            type: "nextRound",
            data: currentRound
          },
          function(error) {
            if (error) {
              alert("Failed to tell everyone to increment round...");
            }
          });

          session.signal({
            type: "newPoints",
            data: totalRounds - currentRound
          }, function(error) {
            if (error) {
              alert("failed to update voter points");
            }
          });
          // If it's the end of the firetalk
          if (currentRound == totalRounds) {
            alert("END OF FIRETALK");
            /*
            session.signal({
              type: "unmuteAll"
            },  function(error) {
              if (error) {
                alert("failed to unmute all");
              }
            });
            */
            // Do some winner logic

            var winningConnectionId = firstSpeakerAlive();

            session.signal({
              type: "winnerColor",
              data: winningConnectionId
            }, function(error) {
              if (error) {
                alert("couldn't set winner color");
              }
            });
            clearInterval(timer);
            timer = null;
          }
          else {
            // unmute first person in list
            session.signal({
              type: "adjustAudio",
              data: firstSpeakerAlive()
            }, function(error) {
                if (error) {
                  alert("cant send unmute ");
                }
            });
          }
        }
        // There are still more people left to speak (guaranteed)
        else {
          // unmute next speaker
          currentSpeakerIndex++;
          for (var i = currentSpeakerIndex; i < playersAlive.length; i++) {
            var connectionId = playersAlive[i];
            if (connectionId) {
              session.signal({
                type: "adjustAudio",
                data: connectionId
              }, function(error) {
                  if (error) {
                    alert("cant send unmute ");
                  }
              });
              break;
            }
          }
        }
      }
    }

    // returns connectionId of the first speaker in the list
    function firstSpeakerAlive() {
      for (var i = 0; i < playersAlive.length; i++) {
        if (playersAlive[i] != null) {
          return playersAlive[i];
        }
      }
    }

    // Checks if the given index is the last speaker alive
    // or that the rest of the elements after it are null
    function isLastSpeakerAlive(index) {
      if (index == 5) {
        return true;
      }
      for (var i = index + 1; i < playersAlive.length; i++) {
        if (playersAlive[i]) {
          return false;
        }
      }
      return true;
    }

    function lowestPointsIndex() {
      var lowestIndex = 0;
      var lowestConnectionId = firstSpeakerAlive();
      var lowestConnection;
      for (var i = 0; i < totalSessions.length; i++) {
        if (totalSessions[i].connection.connectionId == lowestConnectionId) {
          lowestConnection = totalSessions[i].connection;
        }
      }
      for (var i = 0; i < playersAlive.length; i++) {
        if (playersAlive[i]) {
          var connection = totalSessions[i].connection;
          if (parseInt(connection.data.split("|")[0]) < parseInt(lowestConnection.data.split("|")[0])) {
            lowestIndex = i;
            lowestConnection = connection;
          }
        }
      }
      return lowestIndex;
    }

    function dropLowest() {
      alert("dropping lowest");
      var index = lowestPointsIndex();
      playersAlive[index] = null;
      var lowestConnection = totalSessions[index].connection;
      session.signal(
        {
          type: "disconnect",
          data: lowestConnection.connectionId
        },
        function(error) {
          console.log("signal error");
        }
      );
    }
  }
  <% end %>
<% end %>

<% if @user.id == @firetalk.user_id %>
  <button onclick="startFiretalk()" id="startFiretalk">Start Firetalk</button>
<% end %>
