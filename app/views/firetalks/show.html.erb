<script type="text/javascript" src="https://static.opentok.com/v2/js/opentok.min.js"></script>

<%= 'FIRETALK SHOW VIEW' %>

<div id="clock">30</div>
<div id="pointsLeft">3</div>

<div id="speaker1Box" style="border: 1px solid;"></div>
<div id="speaker2Box"></div>
<div id="speaker3Box"></div>
<div id="speaker4Box"></div>
<div id="speaker5Box"></div>
<div id="speaker6Box"></div>

<div id="speakerOnePoints">0</div>
<div id="speakerTwoPoints">0</div>
<div id="speakerThreePoints">0</div>
<div id="speakerThreePoints">0</div>
<div id="speakerFourPoints">0</div>
<div id="speakerFivePoints">0</div>
<div id="speakerSixPoints">0</div>

<%= javascript_tag do %>
var apiKey = '45241592';
var sessionId = "<%= j @firetalk.tok_session_id %>";
var token = "<%= j @tok_token %>";
var myEmail = "<%= j @user.email %>"
var debatersJson = JSON.parse("<%= j @firetalk_json.to_s.html_safe %>");
var session;

// starting number of points
var votingPoints = 3;

// connecting logic
TB.setLogLevel(TB.DEBUG);
var session = TB.initSession(sessionId);
var totalStreams = [];
var audioSubscribers = [];

session.addEventListener('sessionConnected', sessionConnectedHandler);
session.addEventListener('streamCreated', streamCreatedHandler);
session.addEventListener('streamDestroyed', streamDestroyedHandler);
session.connect(apiKey, token);

var publisher;
function sessionConnectedHandler(event) {
    var speakerNumber = parseInt(debatersJson[myEmail] + 1);
    publisher = OT.initPublisher(apiKey, "speaker" + speakerNumber + "Box");
    session.publish(publisher);

    // Subscribe to streams that were in the session when we connected
    subscribeToStreams(event.streams);
}

function streamCreatedHandler(event) {
    subscribeToStreams(event.streams);
}

function subscribeToStreams(streams) {
  for (var i = 0; i < streams.length; i++) {
    // Make sure we donâ€™t subscribe to ourself
    if (streams[i].connection.connectionId == session.connection.connectionId) {
      return;
    }
    // Create the div to put the subscriber element in to
    var div = document.createElement('div');
    div.setAttribute('id', 'stream' + streams[i].streamId);

    var connection = streams[i].connection;
    var email = connection.data.split("|")[1];
    var speakerNumber = parseInt(debatersJson[email]) + 1;
    document.getElementById("speaker" + speakerNumber + "Box").appendChild(div);

    // Subscribe to the stream
    var subscriber = session.subscribe(streams[i], div.id);
    audioSubscribers.push(subscriber);
  }
}

function streamDestroyedHandler(event) {
  connected--;
}

// BROADCAST SIGNAL EVENTS
$('#speakerOnePoints').click(function() {
  session.signal(
    {
      data:  totalStreams[0].connectionId,
      type: "voteSpeakerOne"
    },
    function(error) {
      if (error) {
        alert(error.message);
      }
    }
  );
});

$('#speakerTwoPoints').click(function() {
  session.signal(
    {
      data:  totalStreams[1].connectionId,
      type: "voteSpeakerTwo"
    },
    function(error) {
      if (error) {
        alert(error.message);
      }
    }
  );
});

// LISTENER SIGNAL EVENTS

// Listener SpeakerOneUpvote
session.on(
  "signal:voteSpeakerOne", function(event) {
    var newPoints = incrementStream(event.data);
    $('#speakerOnePoints').html(newPoints);
  }
);

session.on(
  "signal:voteSpeakerTwo", function(event) {
    var newPoints = incrementStream(event.data);
    $('#speakerTwoPoints').html(newPoints);
  }
);

function incrementStream(connectionId) {
  for (var i = 0; i < totalStreams.length; i++) {
    if (String(totalStreams[i].connectionId) == String(connectionId)) {
      var data = totalStreams[i].data.split("|");
      totalStreams[i].data = parseInt(data[0]) + 1 + "|" + data[1];
      return parseInt(data[0]) + 1;
    }
  }
  return 0;
}

// Get whoever connected and add to list
session.on(
  "connectionCreated", function(event) {
    var connection = event.connection;
    var emailAndPoints = connection.data.split("|");

    // JSON points email => Speaker number
    // totalStreams puts people in the right order by speaker number
    totalStreams[parseInt(debatersJson[emailAndPoints[1]])] = connection;
  }
);

// Listen to ourselves if we lose
session.on(
  "signal:disconnect", function(event) {
    session.disconnect();
  }
);

session.on(
  "signal:decrementClock", function(event) {
    var currentTime = $('#clock');
    currentTime.html(event.data);
});

session.on(
  "signal:resetTimer", function(event) {
  currentTime.html(30);
});

// Recieving Points
<% end %>

<% if session[:user_id].to_s == params[:user_id].to_s %>
  <%= javascript_tag do %>
  function startFiretalk() {
    $('#startFiretalk').hide();
    // OWNER LOGIC (Clock every second, muting people, etc.)
    // WRAP IN START FUNCTION, EXECUTE ON CLICK

    var playersAlive [];
    for (var i = 0; i < totalStreams.length; i++) {
      playersAlive[i] = totalStreams[i].connectionId;
    }
    var timer = null;

    // loop through connections and rounds and do this a bunch of times
    if (!timer) {
      timer = setInterval(clockwork, 1000);
    }
    var currentSpeakerIndex = 0;
    var currentRound = 1;

    function clockwork() {
      // if the current index is still alive...
      if (playersAlive[currentSpeakerIndex]) {

        // Clock logic
        var currentTimeLeft = parseInt($('#clock').text(), 10);
        // Timer Still going
        if (currentTimeLeft > 0) {
          var newTime = currentTimeLeft - 1;

          // Lets stick these in helper methods...
          session.signal({
            data: newTime,
            type: "decrementClock"
          },
          function(error) {
            if (error) {
              alert("Failed to update clock, who the fuck knows");
            }
          });
        }
        // Timer Ended (30 seconds up!)
        else {
          // unmute next person, mute everyone else and reset clock to 30 sec (another signal func)
          // if the round is over (bool var?) disconnect the lowest session
          // if we've got a winner, stop everything


          // If we have reached the last speaker in the round
          if (isLastSpeakerAlive(currentSpeakerIndex)) {
            currentRound++;
            dropLowest();
            playersAlive[lowestPointsIndex()] = null;

            if (currentRound == 6) {
              // Do some winner logic
              clearInterval(timer);
              timer = null;
            }

            // otherwise increment the round and do it again!
            else {
              session.signal({
                type: "nextRound"
              },
              function(error) {
                if (error) {
                  alert("Failed to tell everyone to increment round...");
                }
              });
            }
          }
          else {
            // Move on to the next index
            currentSpeakerIndex++;
          }
        }
      }
      // Find the next speaker who isn't dead
      else {
        currentSpeakerIndex++;
      }
    }

    // Checks if the given index is the last speaker alive
    // or that the rest of the elements after it are null
    function isLastSpeakerAlive(index) {
      if (index == 5) {
        return true;
      }
      for (var i = index + 1; i < playersAlive.length; i++) {
        if (playersAlive[i]) {
          return false;
        }
      }
      return true;
    }

    function lowestPointsIndex() {
      var lowestIndex = 0;
      var lowestConnection = totalStreams[0];
      for (var i = 0; i < totalStreams.length; i++) {
        var lowestConnectionPoints = parseInt(lowestConnection.data.split("|")[0]);
        var compareConnectionPoints = parseInt(totalStreams[i].data.split("|")[0]);
        if (compareConnectionPoints < lowestConnectionPoints) {
          lowestConnection = totalStreams[i];
          lowestIndex = i;
        }
      }
      return lowestIndex;
    }

    function dropLowest() {
      var lowestConnection = totalStreams[0];
      for (var i = 1; i < totalStreams.length; i++) {
        var lowestConnectionPoints = parseInt(lowestConnection.data.split("|")[0]);
        var compareConnectionPoints = parseInt(totalStreams[i].data.split("|")[0]);
        if (compareConnectionPoints < lowestConnectionPoints) {
          lowestConnection = totalStreams[i];
        }
      }
      session.signal(
        {
          to: lowestConnection,
          type: "disconnect"
        },
        function(error) {
          console.log("signal error (" + error.code + "): " + error.message);
        }
      );
    }
  }
  <% end %>
<% end %>

<% if @user.id == @firetalk.user_id %>
  <button onclick="startFiretalk()" id="startFiretalk">Start Firetalk</button>
<% end %>
