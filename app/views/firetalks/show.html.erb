<script type="text/javascript" src="https://static.opentok.com/v2/js/opentok.min.js"></script>





<div class="firetalk-container">

<div class="firetalk-row-1">



  <div class="firetalk-sidebar">

    <div id="clock">10</div>
<div id="pointsLeft">3</div>
<p>ROUND NUMBER</p>
<div id="roundNumber">1</div>

<<<<<<< HEAD
  </div>



  <div class="firetalk-main">

    <div class="speakerbox">
      <%= image_tag("videoboxpix.png", :style => "height:198px;width:264px;")%>
      <span>Speaker One</span>
<div id="speaker1Box" class="videobox"></div>
<div id="speakerOnePoints">0</div>
    </div>

    <div class="speakerbox">
      <span>Speaker Two</span>
<div id="speaker2Box" class="videobox"></div>
<div id="speakerTwoPoints">0</div>
    </div>

    <div class="speakerbox">
      <%= image_tag("videoboxpix.png", :style => "height:198px;width:264px;")%>
      <span>Speaker Three</span>
<div id="speaker3Box" class="videobox"></div>

<div id="speakerThreePoints">0</div>
    </div>

    <div class="speakerbox">
      <%= image_tag("videoboxpix.png", :style => "height:198px;width:264px;")%>
      <div id="speaker4Box" class="videobox"></div>
      <div id="speakerFourPoints">0</div>
    </div>

    <div class="speakerbox">
      <%= image_tag("videoboxpix.png", :style => "height:198px;width:264px;")%>
      <div id="speaker5Box" class="videobox"></div>
      <div id="speakerFivePoints">0</div>
    </div>

    <div class="speakerbox">
      <%= image_tag("videoboxpix.png", :style => "height:198px;width:264px;")%>
      <div id="speaker6Box" class="videobox"></div>
      <div id="speakerSixPoints">0</div>
    </div>









  </div>



  <div class="firetalk-bottom-bar">

  </div>



</div>


  </div>


=======
<div id="speaker1Box" class="speakerBox"></div>
<div id="speaker2Box" class="speakerBox"></div>
<div id="speaker3Box" class="speakerBox"></div>
<div id="speaker4Box" class="speakerBox"></div>
<div id="speaker5Box" class="speakerBox"></div>
<div id="speaker6Box" class="speakerBox"></div>

<div id="speakerOnePoints" class="points">0</div>
<div id="speakerTwoPoints" class="points">0</div>
<div id="speakerThreePoints" class="points">0</div>
<div id="speakerFourPoints" class="points">0</div>
<div id="speakerFivePoints" class="points">0</div>
<div id="speakerSixPoints" class="points">0</div>
>>>>>>> refs/remotes/rhenvar/master

<%= javascript_tag do %>

var apiKey = '45241592';
var sessionId = "<%= j @firetalk.tok_session_id %>";
var token = "<%= j @tok_token %>";
var myEmail = "<%= j @user.email %>"
var debatersJson = JSON.parse("<%= j @firetalk_json.to_s.html_safe %>");

var totalSessions = [];
var session = TB.initSession(sessionId);
var speakerNumber = parseInt(debatersJson[myEmail] + 1);
var publisher = OT.initPublisher(apiKey, "speaker" + speakerNumber + "Box");
var votingPoints = 3;

window.onload = function() {
  setup();
};

function setup() {
  // connecting logic
  TB.setLogLevel(TB.DEBUG);

  session.addEventListener('sessionConnected', sessionConnectedHandler);
  session.addEventListener('streamCreated', streamCreatedHandler);
  session.addEventListener('streamPropertyChanged', streamPropertyChangedHandler)
  session.connect(apiKey, token);

  var totalPoints = $('.points');
  for (var i = 0; i < totalPoints.length; i++) {
    totalPoints[i].style.visibility = "hidden";
  }
}

function sessionConnectedHandler(event) {
    session.publish(publisher);
    var id = document.createTextNode(String(session.connection.connectionId));
    document.body.appendChild(id);

    // Subscribe to streams that were in the session when we connected
    subscribeToStreams(event.streams);
}

// try out hovering stuff here?
var totalBoxes = $('.speakerBox');
alert(totalBoxes.length);
for (var i = 0; i < totalBoxes.length; i++) {
  totalBoxes[i].onmouseover = hover;
  totalBoxes[i].onmouseout = unhover;
}

function hover() {
  // make an ajax request, a div that follows the cursor, and publish to that div
  var box = this;
  var ajax = new XMLHttpRequest();
  ajax.onload = function() {
    var data = JSON.parse(this.responseText);
    var infoBox = document.createElement('div');
    infoBox.classList.add("sampleClass");
    infoBox.style.height = "100px";
    infoBox.style.width = "200px";
    infoBox.innerHTML = data[0]["position_description"] + " <br /> " + data[0]["email"];
    box.appendChild(infoBox);
  };
  ajax.open("GET", "<%= j user_firetalk_path(:id => @firetalk.id).to_s << '.json' %>", true);
  ajax.send();
}

function unhover() {
  var hoverInfo = document.querySelectorAll("sampleClass");
  for (var i = 0; i < hoverInfo.length; i++) {
    this.removeChild(hoverInfo[i]);
  }
}

function streamCreatedHandler(event) {
    subscribeToStreams(event.streams);
}

function subscribeToStreams(streams) {
  for (var i = 0; i < streams.length; i++) {
    // Make sure we donâ€™t subscribe to ourself
    if (streams[i].connection.connectionId == session.connection.connectionId) {
      return;
    }
    // Create the div to put the subscriber element in to
    var div = document.createElement('div');
    div.setAttribute('id', 'stream' + streams[i].streamId);

    var connection = streams[i].connection;
    var email = connection.data.split("|")[1];
    var newSpeakerNumber = parseInt(debatersJson[email]) + 1;
    document.getElementById("speaker" + newSpeakerNumber + "Box").appendChild(div);

    // Subscribe to the stream
    session.subscribe(streams[i], div.id);
  }
}

function streamPropertyChangedHandler() {
}

// BROADCAST SIGNAL EVENTS
function decrementVote() {
  session.signal({
    to: session.connection,
    type: "decrementVote",
    data: votingPoints - 1
  }, function(error) {
    if (error) {
      alert("error decrementing votes");
    }
  });
}

$('#speakerOnePoints').click(function() {
  if (parseInt(document.getElementById("pointsLeft").innerHTML) > 0) {
    session.signal(
      {
        data: totalSessions[0].connection.connectionId,
        type: "voteSpeakerOne"
      },
      function(error) {
        if (error) {
          alert(error.message);
        }
      }
    );
    decrementVote();
  }
});

$('#speakerTwoPoints').click(function() {
  if (parseInt(document.getElementById("pointsLeft").innerHTML) > 0) {
    session.signal(
      {
        data:  totalSessions[1].connection.connectionId,
        type: "voteSpeakerTwo"
      },
      function(error) {
        if (error) {
          alert(error.message);
        }
      }
    );
    decrementVote();
  }
});
// and so on and so forth until speaker 6...

// LISTENER EVENTS
session.on(
  "signal:decrementVote", function(event) {
    document.getElementById('pointsLeft').innerHTML = event.data;
    votingPoints = votingPoints - 1;
  }
);

// Listener SpeakerOneUpvote
session.on(
  "signal:voteSpeakerOne", function(event) {
    var newPoints = incrementStream(event.data);
    $('#speakerOnePoints').html(newPoints);
  }
);

// Listener SpeakerTwoUpvote
session.on(
  "signal:voteSpeakerTwo", function(event) {
    var newPoints = incrementStream(event.data);
    $('#speakerTwoPoints').html(newPoints);
  }
);


// Stores the points of the connection locally and returns the value
function incrementStream(connectionId) {
  for (var i = 0; i < totalSessions.length; i++) {
    if (String(totalSessions[i].connection.connectionId) == String(connectionId)) {
      var data = totalSessions[i].connection.data.split("|");
      totalSessions[i].connection.data = parseInt(data[0]) + 1 + "|" + data[1];
      return parseInt(data[0]) + 1;
    }
  }
  return 0;
}

// Get whoever connected and add to list
session.on(
  "connectionCreated", function(event) {
    var emailAndPoints = event.connection.data.split("|");

    // JSON points email => Speaker number
    // totalSessions puts people in the right order by speaker number
    totalSessions[parseInt(debatersJson[emailAndPoints[1]])] = event;
  }
);

// Listen to ourselves if we lose
session.on(
  "signal:disconnect", function(event) {
    if (session.connection.connectionId == event.data) {
      session.unpublish(publisher);
    }
  });

session.on(
  "signal:decrementClock", function(event) {
    var currentTime = $('#clock');
    currentTime.html(event.data);
});

session.on(
  "signal:resetTimer", function(event) {
  $('#clock').html("10");
});

session.on(
  "signal:adjustAudio", function(event) {
    if (event.data == session.connection.connectionId) {
      alert("your turn to speak");
      publisher.publishAudio(true);
    }
    else {
      publisher.publishAudio(false);
    }
  }
);

session.on(
  "signal:nextRound", function(event) {
    var currentRound = $('#roundNumber');
    currentRound.html(event.data);
  }
);

session.on(
  "signal:removeButtons", function(event) {
    var myIndex = parseInt(debatersJson[myEmail]);
    $('button.OT_edge-bar-item.OT_mute.OT_mode-auto').each(function(index) {
      if (myIndex == index) {
        $(this).hide();
      }
    });
  }
);

session.on(
  "signal:unmuteAll", function(event) {
    publisher.publishAudio(true);
  }
);
<% end %>

<% if session[:user_id].to_s == params[:user_id].to_s %>
  <%= javascript_tag do %>
  function startFiretalk() {
    $('#startFiretalk').hide();
    var totalPoints = $('.points');
    for (var i = 0; i < totalPoints.length; i++) {
      totalPoints[i].style.visibility = "visible";
    }

    var totalPoints = document.querySelectorAll('points');
    for (var i = 0; i < totalPoints; i++) {
      totalPoints[i].show();
    }

    session.signal({
      type: "removeButtons"
      }, function(error) {
        if (error) {
          alert("couldn't tell people to fix buttons");
        }
    });
    session.signal({
      type: "showVotes"
    }, function(error) {
      if (error) {
      }
    }
    );

    // OWNER LOGIC (Clock every second, muting people, etc.)
    // WRAP IN START FUNCTION, EXECUTE ON CLICK

    // Players alive is an array containing the connectionIds of all debaters
    // throughout the firetalk we will nullify the connections that are dropped
    // each round, and keep track of the next speaker (connectionId) in line
    var playersAlive = [];
    for (var i = 0; i < totalSessions.length; i++) {
      if (totalSessions[i]) {
        playersAlive[i] = totalSessions[i].connection.connectionId;
      }
    }


    // OWNER START SPEAKING
    adjustAudio(session.connection.connectionId);

    function decrementClock(newTime) {
      session.signal({
        data: newTime,
        type: "decrementClock"
      },
      function(error) {
        if (error) {
          alert("Failed to update clock, who knows");
        }
      });
    }

    function resetTimer() {
      session.signal({
        type: "resetTimer"
      }, function(error) {
        if (error) {
          alert("Failed to reset clock");
        }
      });
    }

    function nextRound(currentRound) {
      session.signal({
        type: "nextRound",
        data: currentRound
      },
      function(error) {
        if (error) {
          alert("Failed to tell everyone to increment round...");
        }
      });
    }

    function newPoints(points) {
      session.signal({
        type:"decrementVote",
        data: points
      }, function(error) {
        if (error) {

        }
      });
    }

    function adjustAudio(connectionId) {
      session.signal(
        {
          type: "adjustAudio",
          data: connectionId
        }, function(error) {
          if (error) {};
        }
      )
    }

    var timer = null;
    if (!timer) {
      timer = setInterval(clockwork, 1000);
    }

    var totalRounds = 2;
    var currentRound = 1;
    var currentSpeakerIndex = 0;

    // Firetalk logic function
    // First speaker (owner) is ALREADY speaking when this method is called
    function clockwork() {
      // Clock logic
      var currentTimeLeft = parseInt($('#clock').text(), 10);

      // Timer Still going
      if (currentTimeLeft > 0) {
        var newTime = currentTimeLeft - 1;
        decrementClock(newTime);
      }
      // Timer Ended (30 seconds up!)
      else {
        // unmute next person, mute everyone else and reset clock to 30 sec (another signal func)
        // if the round is over (bool var?) disconnect the lowest session
        // if we've got a winner, stop everything
        resetTimer();

        // If we have reached the last speaker (a.k.a it's time for a new round)
        if (isLastSpeakerAlive(currentSpeakerIndex)) {
          alert("reached the last speaker at the end of the timer, current round is " + currentRound);
          // Go back to the beginning of our list at the end of the round
          currentSpeakerIndex = 0;

          // otherwise increment the round and do it again!
          // and drop the lowest dude
          currentRound++;
          dropLowest();
          nextRound(currentRound);
          newPoints(totalRounds - currentRound);

          // If it's the end of the firetalk
          if (currentRound == totalRounds) {
            alert("END OF FIRETALK");
            session.signal({
              type: "unmuteAll"
            },  function(error) {
              if (error) {
                alert("failed to unmute all");
              }
            });
            // Do some winner logic
            clearInterval(timer);
            timer = null;
          }
          else {
            // unmute first person in list
            adjustAudio(firstSpeakerAlive());
          }
        }
        // There are still more people left to speak (guaranteed)
        else {
          // unmute next speaker
          currentSpeakerIndex++;
          for (var i = currentSpeakerIndex; i < playersAlive.length; i++) {
            var connectionId = playersAlive[i];
            if (connectionId) {
              adjustAudio(connectionId);
              break;
            }
          }
        }
      }
    }

    // returns connectionId of the first speaker in the list
    function firstSpeakerAlive() {
      for (var i = 0; i < playersAlive.length; i++) {
        if (playersAlive[i] != null) {
          return playersAlive[i];
        }
      }
    }

    // Checks if the given index is the last speaker alive
    // or that the rest of the elements after it are null
    function isLastSpeakerAlive(index) {
      if (index == 5) {
        return true;
      }
      for (var i = index + 1; i < playersAlive.length; i++) {
        if (playersAlive[i]) {
          return false;
        }
      }
      return true;
    }

    function lowestPointsIndex() {
      var lowestIndex = 0;
      var lowestConnectionId = firstSpeakerAlive();
      var lowestConnection;
      for (var i = 0; i < totalSessions.length; i++) {
        if (totalSessions[i].connection.connectionId == lowestConnectionId) {
          lowestConnection = totalSessions[i].connection;
        }
      }
      for (var i = 0; i < playersAlive.length; i++) {
        if (playersAlive[i]) {
          var connection = totalSessions[i].connection;
          if (parseInt(connection.data.split("|")[0]) < parseInt(lowestConnection.data.split("|")[0])) {
            lowestIndex = i;
            lowestConnection = connection;
          }
        }
      }
      return lowestIndex;
    }

    function dropLowest() {
      alert("dropping lowest");
      var index = lowestPointsIndex();
      playersAlive[index] = null;
      var lowestConnection = totalSessions[index].connection;
      session.signal(
        {
          type: "disconnect",
          data: lowestConnection.connectionId
        },
        function(error) {
          console.log("signal error");
        }
      );
    }
  }
  <% end %>
<% end %>