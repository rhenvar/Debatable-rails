<script type="text/javascript" src="https://static.opentok.com/v2/js/opentok.min.js"></script>


<div class="section" id="toppad">


      <div class="col span_2_of_10">
        <div class="ft-left-bar float-right">

          <div class="firetalk-info">



<h2><%= @firetalk.name %></h2>
<h3><em><%= @firetalk.topic %></em></h3>

<em>
<%= @firetalk.description %>
</em>


</br></br>
participants:

<%= @users[0].email %>

<%= @users[1].email %>
</div>

</br>
          <div class="centerhor">
            <% if @user.id == @firetalk.user_id %>
            <button id="startFiretalk" class="button">
              Start Firetalk
            </button>
            <% end %>
          </div>
        </div>
      </div>



  <div class="col span_7_of_10-ft" id="center-col-ft">
    <div class="section group firetalktopbar-container">

      <div class="col span_1_of_3">
        <span class="margleft">
          Time:
        </span>
        <span id="clock">
          15
        </span>
      </div>

      <div class="col span_1_of_3">
        <span class="centerhor">Your Votes Left:</span>
        <span id="pointsLeft" class="centerhor">
          5
        </span>
      </div>

      <div class="col span_1_of_3">
        <span id="roundNumber" class="float-right">
          1
        </span>
        <span class="float-right">Round:</span>
      </div>
    </div>

    <div class="section">

        <div class="col span_1_of_3 full-ft-speaker-box">
            <div id="speaker1Box" class="speakerBox">
          </div>
          <div class="speaker-options">
            <div id="speaker1Points" class="speakerPoints">
              0
            </div>

            <span class="totalvotes">total votes</span>
            <%= @users[0].firstname %>

            <!--

            <%= image_tag("infobutton.svg", :class =>"infobutton")%>

          -->

          </div>


        </div>



        <div class="col span_1_of_3  full-ft-speaker-box">
          <div id="speaker2Box" class="speakerBox">
          </div>

          <div class="speaker-options">
          <div id="speaker2Points" class="speakerPoints">
            0
          </div>
          <span class="totalvotes">total votes</span>
          <%= @users[1].firstname %>
        </div>
        </div>



        <div class="col span_1_of_3 full-ft-speaker-box">
          <div id="speaker3Box" class="speakerBox">

          </div>

        <div class="speaker-options">
          <div id="speaker3Points" class="speakerPoints">
            0
          </div>
          <span class="totalvotes">total votes</span>
        </div>
      </div>
      <div class="section">

        <div class="col span_1_of_3 full-ft-speaker-box">
          <div id="speaker4Box" class="speakerBox">

          </div>

          <div class="speaker-options">
          <div id="speaker4Points" class="speakerPoints">
            0
          </div>
          <span class="totalvotes">total votes</span>
        </div>
        </div>

        <div class="col span_1_of_3 full-ft-speaker-box">
          <div id="speaker5Box" class="speakerBox">

          </div>
          <div class="speaker-options">
          <div id="speaker5Points" class="speakerPoints">
            0
          </div>
          <span class="totalvotes">
            total vote
          </span>
        </div>
        </div>

        <div class="col span_1_of_3 full-ft-speaker-box">
          <div id="speaker6Box" class="speakerBox">
          </div>
          <div class="speaker-options">
          <div id="speaker6Points" class="speakerPoints">
            0
          </div>
          <span class="totalvotes">total votes</span>
        </div>
      </div>

    </div>
  </div>
  <div class="col span_1_of_10">
  </div>
</div>





<!================================-->

<!LOCAL JAVASCRIPT-->

<!================================-->


<%= javascript_tag do %>
var apiKey = '45241592';
var sessionId = "<%= j @firetalk.tok_session_id %>";
var token = "<%= j @tok_token %>";
var myEmail = "<%= j @user.email %>"
var debatersJson = JSON.parse("<%= j @firetalk_json.to_s.html_safe %>");
var isDebater = "<%= @is_debater %>"
var firetalkGoing = false;
var playersAlive = [];

// connecting logic
TB.setLogLevel(TB.DEBUG);
var session = TB.initSession(sessionId);
var totalSessions = [];


var totalPoints = $('.speakerPoints');
for (var i = 0; i < totalPoints.length; i++) {
  totalPoints[i].style.visibility = "hidden";
}

session.addEventListener('sessionConnected', sessionConnectedHandler);
session.addEventListener('streamCreated', streamCreatedHandler);
session.addEventListener('streamPropertyChanged', streamPropertyChangedHandler)
session.connect(apiKey, token);

var publisher;
var speakerNumber;
var publisherOptions = {width: '100%', height: '100%'};

function sessionConnectedHandler(event) {
  var myDiv = document.createElement('div');
  speakerNumber = parseInt(debatersJson[myEmail] + 1);
  publisher = OT.initPublisher(apiKey, myDiv, publisherOptions);
  document.getElementById("speaker" + speakerNumber + "Box").appendChild(myDiv);
  if (isDebater) {
    session.publish(publisher);
  }
  var id = document.createTextNode(String(session.connection.connectionId));
  document.body.appendChild(id);

  // Subscribe to streams that were in the session when we connected
  subscribeToStreams(event.streams);
}

function streamCreatedHandler(event) {
    subscribeToStreams(event.streams);
}

var options = {height: "100%", width: "100%"}

function subscribeToStreams(streams) {
  for (var i = 0; i < streams.length; i++) {
    // Make sure we donâ€™t subscribe to ourself
    if (streams[i].connection.connectionId == session.connection.connectionId) {
      return;
    }
    // Create the div to put the subscriber element in to
    var div = document.createElement('div');
    div.setAttribute('id', 'stream' + streams[i].streamId);

    var connection = streams[i].connection;
    var email = connection.data.split("|")[1];
    var newSpeakerNumber = parseInt(debatersJson[email]) + 1;
    document.getElementById("speaker" + newSpeakerNumber + "Box").appendChild(div);

    // Subscribe to the stream
    session.subscribe(streams[i], div.id, options);
  }
}

function streamPropertyChangedHandler() {
}

function decrementVote() {
  var points = document.getElementById("pointsLeft");
  var left = points.innerHTML;
  points.innerHTML = parseInt(left) - 1;
}

function getPoints() {
  return parseInt(document.getElementById('pointsLeft').innerHTML);
}

// BROADCAST SIGNAL EVENTS
$('#speaker1Points').click(function() {
  if (hasPointsLeft() && speakerNumber != 1) {
    decrementVote();
    session.signal(
      {
        data: totalSessions[0].connection.connectionId,
        type: "voteSpeakerOne"
      },
      function(error) {
        if (error) {
          alert(error.message);
        }
      }
    );
  }
});

$('#speaker2Points').click(function() {
  if (hasPointsLeft() && speakerNumber != 2) {
    session.signal(
      {
        data:  totalSessions[1].connection.connectionId,
        type: "voteSpeakerTwo"
      },
      function(error) {
        if (error) {
          alert(error.message);
        }
      }
    );
    decrementVote();
  }
});

$('#speaker3Points').click(function() {
  if (hasPointsLeft() && speakerNumber != 3) {
    session.signal(
      {
        data:  totalSessions[2].connection.connectionId,
        type: "voteSpeakerThree"
      },
      function(error) {
        if (error) {
          alert(error.message);
        }
      }
    );
    decrementVote();
  }
});

$('#speaker4Points').click(function() {
  if (hasPointsLeft() && speakerNumber != 4) {
    session.signal(
      {
        data:  totalSessions[3].connection.connectionId,
        type: "voteSpeakerFour"
      },
      function(error) {
        if (error) {
          alert(error.message);
        }
      }
    );
    decrementVote();
  }
});

$('#speaker5Points').click(function() {
  if (hasPointsLeft() && speakerNumber != 5) {
    session.signal(
      {
        data:  totalSessions[4].connection.connectionId,
        type: "voteSpeakerFive"
      },
      function(error) {
        if (error) {
          alert(error.message);
        }
      }
    );
    decrementVote();
  }
});

$('#speaker6Points').click(function() {
  if (hasPointsLeft() && speakerNumber != 6) {
    session.signal(
      {
        data:  totalSessions[5].connection.connectionId,
        type: "voteSpeakerSix"
      },
      function(error) {
        if (error) {
          alert(error.message);
        }
      }
    );
    decrementVote();
  }
});

function hasPointsLeft() {
  var points = parseInt(document.getElementById("pointsLeft").innerHTML);
  return points > 0;
}

// LISTENER EVENTS
session.on(
  "signal:winnerColor", function(event) {
    var email;
    for (var i = 0; i < totalSessions.length; i++) {
      if (totalSessions[i].connection.connectionId == event.data) {
        email = totalSessions[i].connection.data.split("|")[1];
      }
    }
    speakerIndex = parseInt(debatersJson[email]) + 1;
    document.getElementById('speaker' + speakerIndex + 'Box').style.border = "4px solid #ffff33";
  }
);
session.on(
  "signal:decrementVote", function(event) {
    document.getElementById('pointsLeft').innerHTML = event.data;
  }
);

// Listener SpeakerOneUpvote
session.on(
  "signal:voteSpeakerOne", function(event) {
    var newPoints = incrementStream(event.data);
    $('#speaker1Points').html(newPoints);
  }
);

// Listener SpeakerTwoUpvote
session.on(
  "signal:voteSpeakerTwo", function(event) {
    var newPoints = incrementStream(event.data);
    $('#speaker2Points').html(newPoints);
  }
);

session.on(
  "signal:voteSpeakerThree", function(event) {
    var newPoints = incrementStream(event.data);
    $('#speaker3Points').html(newPoints);
  }
);

session.on(
  "signal:voteSpeakerFour", function(event) {
    var newPoints = incrementStream(event.data);
    $('#speaker4Points').html(newPoints);
  }
);

session.on(
  "signal:voteSpeakerFive", function(event) {
    var newPoints = incrementStream(event.data);
    $('#speaker5Points').html(newPoints);
  }
);

session.on(
  "signal:voteSpeakerSix", function(event) {
    var newPoints = incrementStream(event.data);
    $('#speaker6Points').html(newPoints);
  }
);

// Stores the points of the connection locally and returns the value
function incrementStream(connectionId) {
  for (var i = 0; i < totalSessions.length; i++) {
    if (String(totalSessions[i].connection.connectionId) == String(connectionId)) {
      var data = totalSessions[i].connection.data.split("|");
      totalSessions[i].connection.data = parseInt(data[0]) + 1 + "|" + data[1];
      return parseInt(data[0]) + 1;
    }
  }
  return 0;
}

// Get whoever connected and add to list
session.on(
  "connectionCreated", function(event) {
    var emailAndPoints = event.connection.data.split("|");

    // JSON points email => Speaker number
    // totalSessions puts people in the right order by speaker number

    // RECONNECTING LOGIC
    var newSession = event;

    if (firetalkGoing) {
      alert("connected!@");
      var index = parseInt(debatersJson[emailAndPoints[1]]);
      if (playersAlive[index]) {
        playersAlive[index] == newSession.connection.connectionId;
        showPoints();
      }
    }
    totalSessions[parseInt(debatersJson[emailAndPoints[1]])] = newSession;
  }
);

function showPoints() {
  session.signal({
    type: "showPoints"
  }, function(error) {
    if (error) {
      alert("couldn't show points");
    }
  });
}

// Listen to ourselves if we lose
session.on(
  "signal:disconnect", function(event) {
    if (session.connection.connectionId == event.data) {
      // Instead of just unpublishing, permanently mute and set style to black
      publisher.publishAudio(false);
      document.getElementById('speaker' + speakerNumber + 'Box').style.backgroundColor = "black";

      session.signal({
        type: 'dropColor',
        data: session.connection.connectionId
        }, function(error) {
          if (error) {
            console.log("problem changing colors");
          }
        }
      );
      session.signal({
        type: 'hideLoserButton',
        data: speakerNumber
        }, function(error) {
          if (error) {
            console.log("problem hiding button");
          }
        }
      );
    }
  }
);

session.on(
  "signal:hideLoserButton", function(event) {
    var loserNumber = parseInt(event.data);
    $('#speaker' + loserNumber + 'Points').unbind();
  }
);


session.on(
  "signal:dropColor", function(event) {
    var email;
    for (var i = 0; i < totalSessions.length; i++) {
      if (totalSessions[i].connection.connectionId == event.data) {
        email = totalSessions[i].connection.data.split("|")[1];
      }
    }
    var debaterIndex = parseInt(debatersJson[email]);
    debaterIndex++;
    document.getElementById('speaker' + debaterIndex + 'Box').style.border = "4px solid #000000";
  }
);

session.on(
  "signal:decrementClock", function(event) {
    var currentTime = $('#clock');
    currentTime.html(event.data);
});

session.on(
  "signal:resetTimer", function(event) {
  $('#clock').html("15");
});

session.on(
  "signal:adjustAudio", function(event) {
    var email;
    for (var i = 0; i < totalSessions.length; i++) {
      if (totalSessions[i].connection.connectionId == event.data) {
        email = totalSessions[i].connection.data.split("|")[1];
      }
    }
    var nowSpeaking = parseInt(debatersJson[email]);
    var totalSpeakerBoxes = $('.speakerBox');
    for (var i = 0; i < totalSpeakerBoxes.length; i++) {
      if (i == nowSpeaking) {
        totalSpeakerBoxes[i].style.border = "4px solid green";
        //startLoadingBar(i + 1);
      }

      // if it's not black, turn it red (if they're not out, mute them for the round)
      else if (totalSpeakerBoxes[i].style.borderColor != "rgb(0, 0, 0)"){
        if (totalSpeakerBoxes[i].style.borderColor != '#000000') {
          totalSpeakerBoxes[i].style.border = "4px solid red";
        }
      }
    }
    // Don't worry about this, it's just muting stuff
    if (event.data == session.connection.connectionId) {

      //$("#speaker" + speakerNumber + "Box").css("border", "4px solid green");

      //$("#speaker" + speakerNumber + "Box").css("background-color", "green");
      publisher.publishAudio(true);
    }
    else {
      publisher.publishAudio(false);
    }
  }
);

var barTimer = null;
function startLoadingBar(speakerIndex) {
  var bar = document.createElement("div");
  bar.id = "speakingBar";
  bar.style.border = "4 px solid pink";
  bar.height = "225px";
  var speakerBox = $('#speaker' + speakerIndex + 'Box');
  // append bar to somewhere?
  barTimer = setInterval(decrementBar, 100);
}

function decrementBar() {
  var currentTimeLeft = parseInt($('#clock').text(), 10);
  var bar = document.getElementById("speakingBar");
  if (currentTimeLeft == 0) {
    clearInterval(barTimer);
    barTimer = null;
    bar.visibility = "hidden";
  }
  else {
    // CHANGE THIS WHEN YOU CHANGE THE TIME
    bar.style.height = currentTimeLeft * 15 / 225;
  }
}

session.on(
  "signal:nextRound", function(event) {
    var currentRound = $('#roundNumber');
    currentRound.html(event.data);
  }
);

session.on(
  "signal:removeButtons", function(event) {
    var myIndex = parseInt(debatersJson[myEmail]);
    $('button.OT_edge-bar-item.OT_mute.OT_mode-auto').each(function(index) {
      if (myIndex == index) {
        $(this).hide();
      }
    });
  }
);

session.on(
  "signal:unmuteAll", function(event) {
    publisher.publishAudio(true);
  }
);

session.on(
  "signal:showPoints", function(event) {
    var points = $('.speakerPoints');
    for (var i = 0; i < points.length; i++) {
      points[i].style.visibility = 'visible';
    }
  }
);

session.on(
  "signal:newPoints", function(event) {
    var newPoints = parseInt(event.data);
    document.getElementById("pointsLeft").innerHTML = newPoints;
  }
);

session.on(
  "signal:prepareNextSpeaker", function(event) {
    var speakerIndex = parseInt(event.data) + 1;
    $("#speaker" + speakerIndex + "Box").css("border", "4px solid blue");
  }
);

<% end %>

<% if session[:user_id].to_s == params[:user_id].to_s %>
  <%= javascript_tag do %>
  var currentSpeakerIndex = 0;
  window.onload = function() {
    $('#startFiretalk').on('click', function() {
      startFiretalk();
    });
  };

  function startFiretalk() {
    $('#startFiretalk').hide();
    firetalkGoing = true;

    showPoints();
    session.signal({
      type: "removeButtons"
      }, function(error) {
        if (error) {
          alert("couldn't tell people to fix buttons");
        }
    });

    // OWNER LOGIC (Clock every second, muting people, etc.)
    // WRAP IN START FUNCTION, EXECUTE ON CLICK

    // Players alive is an array containing the connectionIds of all debaters
    // throughout the firetalk we will nullify the connections that are dropped
    // each round, and keep track of the next speaker (connectionId) in line
    for (var i = 0; i < totalSessions.length; i++) {
      if (totalSessions[i]) {
        playersAlive[i] = totalSessions[i].connection.connectionId;
      }
    }

    // First person start
    session.signal({
      type: "adjustAudio",
      data: totalSessions[0].connection.connectionId
    },
    function(error) {
      if (error) {
        alert("There was an error starting the firetalk with owner");
      }
    });

    var timer = null;
    if (!timer) {
      timer = setInterval(clockwork, 1000);
    }

    var totalRounds = 4;
    var currentRound = 1;

    // Firetalk logic function
    // First speaker (owner) is ALREADY speaking when this method is called
    function clockwork() {
      // Clock logic
      var currentTimeLeft = parseInt($('#clock').text(), 10);

      // Timer Still going
      if (currentTimeLeft > 0) {
        var newTime = currentTimeLeft - 1;

        // Lets stick these in helper methods
        session.signal({
          data: newTime,
          type: "decrementClock"
        },
        function(error) {
          if (error) {
            alert("Failed to update clock, who knows");
          }
        });

        if (currentTimeLeft == 10) {
          // get next speaker speaking
          if (!isLastSpeakerAlive(currentSpeakerIndex)) {
            var nextSpeakerIndex = getNextSpeakerAlive(currentSpeakerIndex);
            //alert("Now: " + currentSpeakerIndex + " next:" + nextSpeakerIndex);

            session.signal({
              type: "prepareNextSpeaker",
              data: nextSpeakerIndex
            }, function(error) {
              if (error) {
                alert("couldn't prepare next speaker");
              }
            });
          }
          else {

          }
        }
      }
      // Timer Ended (30 seconds up!)
      else {
        // unmute next person, mute everyone else and reset clock to 30 sec (another signal func)
        // if the round is over (bool var?) disconnect the lowest session
        // if we've got a winner, stop everything
        session.signal({
          type: "resetTimer"
        }, function(error) {
          if (error) {
            alert("Failed to reset clock");
          }
        });

        // If we have reached the last speaker (a.k.a it's time for a new round)
        if (isLastSpeakerAlive(currentSpeakerIndex)) {
          // and drop the lowest dude
          currentRound++;
          dropLowest();
          // Go back to the beginning of our list at the end of the round
          currentSpeakerIndex = firstIndexAlive();

          session.signal({
            type: "nextRound",
            data: currentRound
          },
          function(error) {
            if (error) {
              alert("Failed to tell everyone to increment round...");
            }
          });

          session.signal({
            type: "newPoints",
            data: totalRounds - currentRound
          }, function(error) {
            if (error) {
              alert("failed to update voter points");
            }
          });
          // If it's the end of the firetalk
          if (currentRound == totalRounds) {
            alert("END OF FIRETALK");
            session.signal({
              type: "unmuteAll"
            },  function(error) {
              if (error) {
                alert("failed to unmute all");
              }
            });
            // Do some winner logic

            var winningConnectionId = firstSpeakerAlive();
            session.signal({
              type: "winnerColor",
              data: winningConnectionId
            }, function(error) {
              if (error) {
                alert("couldn't set winner color");
              }
            });
            clearInterval(timer);
            timer = null;
          }
          else {
            // unmute first person in list
            session.signal({
              type: "adjustAudio",
              data: firstSpeakerAlive()
            }, function(error) {
                if (error) {
                  alert("cant send unmute ");
                }
            });
          }
        }
        // There are still more people left to speak (guaranteed)
        else {
          // unmute next speaker
          currentSpeakerIndex++;
          for (var i = currentSpeakerIndex; i < playersAlive.length; i++) {
            var connectionId = playersAlive[i];
            if (connectionId) {
              session.signal({
                type: "adjustAudio",
                data: connectionId
              }, function(error) {
                  if (error) {
                    alert("cant send unmute ");
                  }
              });
              currentSpeakerIndex = i;
              break;
            }
          }
        }
      }
    }

    function getNextSpeakerAlive(currentSpeaker) {
      for (var i = currentSpeaker; i < playersAlive.length; i++) {
        if (playersAlive[i + 1]) {
          return i + 1;
        }
      }
      for (var i = 0; i < currentSpeaker; i++) {
        if (playersAlive[i]) {
          return i;
        }
      }
    }

    // returns connectionId of the first speaker in the list
    function firstSpeakerAlive() {
      for (var i = 0; i < playersAlive.length; i++) {
        if (playersAlive[i] != null) {
          return playersAlive[i];
        }
      }
    }

    function firstIndexAlive() {
      for (var i = 0; i < playersAlive.length; i++) {
        if (playersAlive[i]) {
          return i;
        }
      }
    }

    // Checks if the given index is the last speaker alive
    // or that the rest of the elements after it are null
    function isLastSpeakerAlive(index) {
      if (index == 5) {
        return true;
      }
      for (var i = index + 1; i < playersAlive.length; i++) {
        if (playersAlive[i]) {
          return false;
        }
      }
      return true;
    }

    function lowestPointsIndex() {
      var lowestIndex = playersAlive.indexOf(firstSpeakerAlive());
      var lowestConnectionId = firstSpeakerAlive();
      var lowestConnection;
      for (var i = 0; i < totalSessions.length; i++) {
        if (totalSessions[i].connection.connectionId == lowestConnectionId) {
          lowestConnection = totalSessions[i].connection;
        }
      }
      for (var i = 0; i < playersAlive.length; i++) {
        if (playersAlive[i] != null) {
          var testConnection = totalSessions[i].connection;
          if (parseInt(testConnection.data.split("|")[0]) < parseInt(lowestConnection.data.split("|")[0])) {
            lowestIndex = i;
            lowestConnection = testConnection;
          }
        }
      }
      return lowestIndex;

      /*
      var alive = playersLeft();
      var aliveConnections = [];

      for (var i = 0; i < totalSessions.length; i++) {
        for (var j = 0; i < alive.length; j++) {
          if (totalSessions[i].connection.connectionId == alive[j]) {
            aliveConnections.push(totalSessions[i].connection);
          }
        }
      }

      var firstConnection = aliveConnections[0];
      var lowestIndex = 0;
      for (var i = 0; i < aliveConnections.length; i++) {
        var firstPoints = parseInt(firstConnection.data.split("|")[0]);
        var secondPoints = parseInt(aliveConnections[i].connection.data.split("|")[0]);
        if (secondPoints > firstPoints) {
          firstConnection = aliveConnections[i].connection;
        }
      }
      */
    }

    function playersLeft() {
      left = [];
      for (var i = 0; i < playersAlive.length; i++) {
        if (players[i]) {
          left.push(players[i]);
        }
      }
      return left;
    }

    function dropLowest() {
      var index = lowestPointsIndex();
      playersAlive[index] = null;
      var lowestConnection = totalSessions[index].connection;
      //alert("dropping " + lowestConnection.connectionId);
      session.signal(
        {
          type: "disconnect",
          data: lowestConnection.connectionId
        },
        function(error) {
          console.log("signal error");
        }
      );
    }
  }
  <% end %>

<% end %>
